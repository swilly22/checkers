<html>
<head>
<title>Checkers</title>
<style>canvas { width: 100%; height: 100% }</style>
</head>
<body>
<script src="js/actions.js"></script>
<script src="js/audio.js"></script>
<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/animator.js"></script>
<script src="js/gameManager.js"></script>
<script src="js/board.js"></script>
<script src="js/checker.js"></script>
<script>

var scene;
var camera;
var renderer;
var WIDTH;
var HEIGHT;
var controls;
var BOARD_WIDTH = 8;
var BOARD_HEIGHT = 8;

var colors = [0X000000,/*WHITE*/0xD6B57A, /*BLACK*/0x321900];
var COLOR_BRIGHTNESS_INC = 0x202020;

var PLAYER_WHITE = 1;
var PLAYER_BLACK = 2;

var animator = new Animator();


// Server
function Server() {    
  this.address = 'ws://10.0.0.5:8080/ws';
  this.callbackQueue = [];
  this.connection = null;
  this.Send = Send;
  this.ActionHandler = ActionHandler;
  this.InitWSConnection = InitWSConnection;
}

function ActionHandler(data) {
  switch(data.action) {
    case ACTIONS.MOVE:
      for(var idx = 0; idx < data.moves.length; idx++) {
        var src = {'x' : data.moves[idx].from[0], 'y' : data.moves[idx].from[1]};
        var dest = {'x' : data.moves[idx].to[0], 'y' : data.moves[idx].to[1]};
        var bEat = data.moves[idx].eat;
        var checker = board.checkers[src.x][src.y];
        if(checker == null) {
          console.log("Error, missing piece");
          return;
        }
        board.MoveChecker(src, dest, bEat);
      }
      break;

    case ACTIONS.QUEENED:
      console.log("queened");
      var piece = board.checkers[data.position.x][data.position.y];
      if(piece == null) {
        console.log("Error, piece missing, probebly out of sync.");
        // TODO Request board.
        break;
      }
      piece.Queened();

    case ACTIONS.OPPONENT_LEFT:
        console.log("Opponent has left the game");
        // Just for fun alow player to move pieces around
        bMyTurn = true;
        break;

    default:
      console.log("Unknow action " + data.action);
      break;
  }
}

// Sends a request over websocket.
function Send(request, callback) {
  
  if(callback != null) {
    this.callbackQueue.push(callback);
  }

  this.connection.send(JSON.stringify(request));
}

function InitWSConnection() {
  this.connection = new WebSocket(this.address);
  var me = this;
  
  this.connection.onopen = function() {
   console.log('Connection open!');
   
   // Send viewer join request.
   var request = {"action" : ACTIONS.VIEWER_JOIN};

   // Server responds with board's state.
   me.Send(request, function OnJoined (response) {
      if(response.result == true) {
        var request = {"action" : ACTIONS.INIT};
        me.Send(request, HandleRequestBoard);
      }
   });
  }

  this.connection.onclose = function() {
   console.log('Connection closed');
  }

  this.connection.onerror = function(error) {
   console.log('Error detected: ' + error);
  }

  this.connection.onmessage = function(e) {
    var server_message = e.data;
    console.log(server_message);

    var data = JSON.parse(e.data);
    if('fromServer' in data) {
      // This is a message generated by the server, no callback is set for it.
      action = data.action;
      return me.ActionHandler(data);
    }
    else {  // This is a response from the server to one of our requests.
      // Pop callback from queue.
      var callback = me.callbackQueue.shift();
      callback(data);
    }
  }
}

// End of server


function Radians(degrees) {
  return 2 * Math.PI * (degrees / 360);
}

function BoardToSpaceCords(position) {
    origin = new THREE.Vector3(0, 0, 0);
    cellX = (BOARD_WIDTH / 8) / 2 ;
    cellY = (BOARD_HEIGHT / 8) / 2;

    row = origin.x + (position.x * cellX * 2) + cellX;
    col = origin.z + (position.y * cellY * 2) + cellY;
    offset = new THREE.Vector3(-col, 0, row);
    return offset;
}

function SpaceToBoardCords(position) {
  row = Math.floor(position.z);
  col = Math.floor(-position.x);

  return {'x' : row, 'y' : col};
}

function CreateFloor() {
    var floorTexture = new THREE.ImageUtils.loadTexture( 'images/checkerboard.jpg' );
    floorTexture.wrapS = floorTexture.wrapT = THREE.RepeatWrapping; 
    floorTexture.repeat.set(2, 2);
    var floorMaterial = new THREE.MeshBasicMaterial( { map: floorTexture, side: THREE.DoubleSide } );
    var floorGeometry = new THREE.PlaneGeometry(BOARD_WIDTH, BOARD_HEIGHT);
    var floor = new THREE.Mesh(floorGeometry, floorMaterial);
    floor.rotation.x = Radians(90);
    floor.position = new THREE.Vector3(-BOARD_WIDTH/2, 0, BOARD_HEIGHT/2);
    return floor;
}

// Sets up camera position according to player's position, 
// each player is facing the board from a different position.
function SetUpCameraViewingPosition(color) {  
  var camera_position;

  if(color == PLAYER_BLACK) {
    camera_position = new THREE.Vector3(-BOARD_WIDTH / 2, 9, BOARD_WIDTH + 6);
  }
  else if(color == PLAYER_WHITE) {
    camera_position = new THREE.Vector3(-BOARD_WIDTH / 2, 9, -6);
  }

  camera.position = camera_position;
  var center = new THREE.Vector3(-BOARD_WIDTH/2, 0, BOARD_HEIGHT/2);
  camera.lookAt(center);
}
function SetUpLights(color) {

  // create a point light
  var pointLight = new THREE.PointLight(0xFFFFFF);

  // set position according to viewer.
  if(color == PLAYER_BLACK) {
    pointLight.position = new THREE.Vector3(-BOARD_WIDTH / 2, 12, BOARD_WIDTH + 6);
  }
  else if(color == PLAYER_WHITE) {
    pointLight.position = new THREE.Vector3(-BOARD_WIDTH / 2, 12, -6);
  }
    // add to the scene
    scene.add(pointLight);
}

function Init() {
    // set the scene size/
    WIDTH = window.innerWidth;
    HEIGHT = window.innerHeight;

    // set some camera attributes
    var VIEW_ANGLE = 45;
    var ASPECT = WIDTH / HEIGHT;
    var NEAR = 0.1;
    var FAR = 10000;

    // create a WebGL renderer, camera and scene. 
    renderer = new THREE.WebGLRenderer();
    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
    //controls = new THREE.OrbitControls(camera, renderer.domElement);

    // Set camera up.    
    camera.up.set(0, 1, 0);

    camera.position = new THREE.Vector3(-BOARD_WIDTH / 2, 9, -6);
    var center = new THREE.Vector3(-BOARD_WIDTH/2, 0, BOARD_HEIGHT/2);
    camera.lookAt(center);
    
    // add the camera to the scene.
    scene.add(camera);

    /*var axisHelper = new THREE.AxisHelper( WIDTH / 2 );
    scene.add( axisHelper );*/

    // Start the renderer
    renderer.setSize(WIDTH, HEIGHT);

    // attach the render-supplied DOM element.
    document.body.appendChild( renderer.domElement );

    window.addEventListener('resize', onWindowResize, false);
    // FLOOR
    var floor = CreateFloor();
    scene.add(floor);

}

function onWindowResize(event) {
  WIDTH = window.innerWidth;
  HEIGHT = window.innerHeight;

  camera.aspect = WIDTH / HEIGHT;
  camera.updateProjectionMatrix();

  renderer.setSize(WIDTH, HEIGHT);
}

function render() {
  requestAnimationFrame(render);
  animator.Animate();
  renderer.render(scene, camera);
  //controls.update();

}

var checker_geometry;
var loader = new THREE.JSONLoader;

function LoadModels() {  
  loader.load('js/Frame.js', function (geometry, materials) {
      var material = new THREE.MeshBasicMaterial( {color: 0xb69b4c,  wireframe: true} );
      var frame = new THREE.Mesh( geometry, material );
      frame.position = new THREE.Vector3(-BOARD_WIDTH/2, 0, BOARD_HEIGHT/2);
      scene.add(frame);
  });

  loader.load('js/checker_mdl.js', function (geometry, materials) {
      checker_geometry = geometry;
  });
}

LoadModels();
Init();

var bMyTurn = false;
var game = new GameManager();
var board = new Board();
var server = new Server();
server.InitWSConnection();

render();

</script>
</body>
</html>